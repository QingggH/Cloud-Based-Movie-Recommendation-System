name: Continuous Deploy
#
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    environment: AWS_DEPLOYMENT

    steps:
      # Step 1: Checkout my code from GitHub
      - name: Checkout Code
        uses: actions/checkout@v3

      # Step 2: Create an SSH key file from GitHub secret
      - name: Create SSH key file
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2_key.pem
          chmod 600 ec2_key.pem

      # Step 3: Configure AWS CLI
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      # Step 4: Check EC2 Instance State
      - name: Check EC2 Instance State
        id: check_state
        run: |
          INSTANCE_ID=i-039c1f8227270d4e5
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[*].Instances[*].State.Name' \
            --output text)
          echo "INSTANCE_STATE=$INSTANCE_STATE" >> $GITHUB_ENV

      # Step 5: Start EC2 Instance if it is stopped
      - name: Start EC2 Instance (if stopped)
        if: env.INSTANCE_STATE == 'stopped'
        run: |
          aws ec2 start-instances --instance-ids i-039c1f8227270d4e5
          echo "Waiting for EC2 instance to start..."
          aws ec2 wait instance-running --instance-ids i-039c1f8227270d4e5

      # Step 6: Fetch the EC2 Public IP
      - name: Get EC2 Public IP
        id: ec2info
        run: |
          INSTANCE_ID=i-039c1f8227270d4e5
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[*].Instances[*].PublicIpAddress' \
            --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      # Step 7: Stop running the previous app and remove old files
      - name: Stop old application
        run: |
          ssh -o StrictHostKeyChecking=no -i ec2_key.pem ubuntu@${{ env.PUBLIC_IP }} <<EOF
            # Kill the running Python process if any
            pkill -f test.py || true
            
            # Remove old application directory
            rm -rf /home/ubuntu/my_flask_app
          EOF

      # Step 8: Copy the local code to EC2
      - name: Copy Code to EC2
        run: |
          scp -o StrictHostKeyChecking=no -i ec2_key.pem -r ./* ubuntu@${{ env.PUBLIC_IP }}:/home/ubuntu/my_flask_app

      # Step 9: SSH into EC2, install dependencies, and run app
      - name: Install & Run Application
        run: |
          ssh -o StrictHostKeyChecking=no -i ec2_key.pem ubuntu@${{ env.PUBLIC_IP }} <<EOF
            # Update system packages and install Python
            sudo apt-get update
            sudo apt-get install -y python3 python3-venv python3-pip

            cd /home/ubuntu/my_flask_app

            # Create and activate a virtual environment
            python3 -m venv venv
            source venv/bin/activate

            # Install dependencies
            pip install -r requirements.txt

            # Run the Python script in background
            nohup python3 test.py > test.log 2>&1 &
          EOF

      # Step 10: Create environment file for the grader
      - name: Setup Variables for Grader Workflow
        run: |
          echo "SSH_HOST=${{ env.PUBLIC_IP }}" > grader-env.txt
          echo "SSH_USER=ubuntu" >> grader-env.txt

      # Step 11: Upload the environment file as an artifact
      - name: Upload Grader Environment Variables
        uses: actions/upload-artifact@v4
        with:
          name: grader-env
          path: grader-env.txt
